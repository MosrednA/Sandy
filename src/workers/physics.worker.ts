import { World } from '../core/World';
import { Phase, CHUNK_SIZE } from '../core/Constants';
import type { OffGridParticle } from '../core/Constants';
import { materialRegistry } from '../materials/MaterialRegistry';
import { registerAllMaterials } from '../materials/registerAll';

// Register all materials (centralized to prevent sync issues)
registerAllMaterials();

let world: World;
let assignedChunks: { cx: number, cy: number }[] = [];
let workerId = -1;
// Reserved for future chunk sleeping optimization
// @ts-expect-error Reserved for future use
let _currentActiveChunks: Uint8Array | null = null;
let jitterX = 0;
let jitterY = 0;

let offGridParticles: OffGridParticle[] = [];

self.onmessage = (e) => {
    const data = e.data;

    if (data.type === 'INIT') {
        const { width, height, buffers, id, assigned } = data;
        workerId = id;
        assignedChunks = assigned;

        world = new World(width, height, buffers);

        console.log(`Worker ${id} initialized with ${assignedChunks.length} chunks.`);
    } else if (data.type === 'PHASE') {
        if (!world) return;

        const phase = data.phase as Phase;

        // Receive activeChunks snapshot for sleep optimization
        if (data.activeChunks) {
            _currentActiveChunks = new Uint8Array(data.activeChunks);
        }

        if (data.jitterX !== undefined) jitterX = data.jitterX;
        if (data.jitterY !== undefined) jitterY = data.jitterY;

        runPhase(phase);

        // Process Physics once per frame (Phase RED is start of frame)
        let particlesToSend: OffGridParticle[] | undefined;
        if (phase === Phase.RED) {
            processOffGridParticles();
            particlesToSend = offGridParticles;
        }

        // Notify done
        self.postMessage({ type: 'DONE', workerId, particles: particlesToSend });
    }
};

function processOffGridParticles() {
    const grid = world.grid;
    // 1. Ingest queued particles from Grid (generated by Explosions this frame)
    if (grid.queuedParticles.length > 0) {
        offGridParticles.push(...grid.queuedParticles);
        grid.queuedParticles = []; // Clear queue
    }

    // 2. Simulate
    const width = grid.width;
    const height = grid.height;

    for (let i = offGridParticles.length - 1; i >= 0; i--) {
        const p = offGridParticles[i];

        // Physics
        p.vy += 0.2; // Gravity
        p.vx *= 0.99; // Drag
        p.vy *= 0.99;

        const nextX = p.x + p.vx;
        const nextY = p.y + p.vy;

        // Bounds Check
        if (nextX < 0 || nextX >= width || nextY < 0 || nextY >= height) {
            // Out of bounds: Destroy
            offGridParticles.splice(i, 1);
            continue;
        }

        // Collision Check (Simple point check at floor)
        const ix = Math.floor(nextX);
        const iy = Math.floor(nextY);

        // If hitting a solid/liquid (non-empty)
        const hitId = grid.get(ix, iy);
        if (hitId !== 0 && hitId !== 255) { // 255 is boundary, handled above logic
            // Hit something! Re-integrate.
            const prevIX = Math.floor(p.x);
            const prevIY = Math.floor(p.y);

            // Check if previous position is valid for placement
            if (grid.get(prevIX, prevIY) === 0) {
                grid.set(prevIX, prevIY, p.id);
                grid.setVelocity(prevIX, prevIY, p.vy); // Transfer momentum

                // Splash Effect
                // If we hit liquid with high velocity, splash some liquid up
                const isLiquid = hitId === 3 || hitId === 8 || hitId === 9 || hitId === 14 || hitId === 20;
                const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);

                if (isLiquid && speed > 3) {
                    // CONSERVATION OF MASS:
                    // Only splash if we can remove a pixel of liquid.
                    // We only splash 1 particle per impact to avoid explosion.
                    // Or we can splash more if we remove more? 
                    // Let's splash 1 particle for now. 

                    // Remove the liquid we hit
                    grid.set(ix, iy, 0);

                    offGridParticles.push({
                        x: ix, // Start at the source liquid position
                        y: iy,
                        vx: (Math.random() - 0.5) * 4, // Random spray
                        vy: -2 - Math.random() * 4, // Upward force
                        id: hitId,
                        color: 0
                    });
                }
            } else {
                // Try to squeeze in? For now just absorb.
            }

            offGridParticles.splice(i, 1);
        } else {
            // Move free
            p.x = nextX;
            p.y = nextY;
        }
    }
}

// Pre-allocated array for shuffled cell indices (reused each chunk)
const cellIndices: number[] = new Array(CHUNK_SIZE * CHUNK_SIZE);
for (let i = 0; i < cellIndices.length; i++) cellIndices[i] = i;

// Fisher-Yates shuffle (in-place, fast)
function shuffleArray(arr: number[], count: number): void {
    for (let i = count - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        const temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}

function runPhase(phase: Phase) {
    const grid = world.grid;
    const width = grid.width;
    const height = grid.height;

    // Increment frame count only on Phase 0
    if (phase === Phase.RED) {
        world.frameCount++;
        grid.frameCount = world.frameCount;
    }

    const isRed = phase === Phase.RED;
    const isBlue = phase === Phase.BLUE;
    const isGreen = phase === Phase.GREEN;
    const isYellow = phase === Phase.YELLOW;

    for (const chunk of assignedChunks) {
        const { cx, cy } = chunk;

        // Check Phase Match (Checkerboard pattern)
        const cxEven = cx % 2 === 0;
        const cyEven = cy % 2 === 0;

        let match = false;
        if (isRed && cxEven && cyEven) match = true;
        else if (isBlue && !cxEven && cyEven) match = true;
        else if (isGreen && cxEven && !cyEven) match = true;
        else if (isYellow && !cxEven && !cyEven) match = true;

        if (!match) continue;

        // Process Chunk with JITTER offset
        let startChunkX = cx * CHUNK_SIZE + jitterX;
        let endChunkX = (cx + 1) * CHUNK_SIZE + jitterX;
        let startY = cy * CHUNK_SIZE + jitterY;
        let endY = (cy + 1) * CHUNK_SIZE + jitterY;

        // Clamp to World Bounds
        startChunkX = Math.max(0, Math.min(width, startChunkX));
        endChunkX = Math.max(0, Math.min(width, endChunkX));
        startY = Math.max(0, Math.min(height, startY));
        endY = Math.max(0, Math.min(height, endY));

        if (startChunkX >= endChunkX || startY >= endY) continue;

        const chunkWidth = endChunkX - startChunkX;
        const chunkHeight = endY - startY;
        const cellCount = chunkWidth * chunkHeight;

        // Shuffle cell indices for this chunk
        shuffleArray(cellIndices, cellCount);

        // Process cells in shuffled order
        for (let i = 0; i < cellCount; i++) {
            const idx = cellIndices[i];
            const localX = idx % chunkWidth;
            const localY = Math.floor(idx / chunkWidth);
            const x = startChunkX + localX;
            const y = startY + localY;

            const id = grid.cells[y * width + x];
            if (id !== 0) {
                const m = materialRegistry.get(id);
                if (m) {
                    m.update(grid, x, y);
                }
            }
        }
    }
}
